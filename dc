#!/bin/bash
##################################
# Copyright (C) 2022 Ben HÃ¤hlen
##################################
# VERSION
export DC_VERSION=v1.6.0-dev

###### VARIABLES
if [[ -z "${DC_DIR}" ]]; then
    export DC_DIR="${HOME}/docker"
else
    export DC_DIR="${DC_DIR}"
fi
export ENV="${DC_DIR}/.env"

if [[ -z "${DC_CMD}" ]]; then
    export DC_CMD="docker compose"
else
    export DC_CMD="${DC_CMD}"
fi

#######################################
export DC_COMMAND="${DC_CMD} --env-file ${ENV}"
export TMP_DIR="/tmp/dc_stack_services"
# COLORS
export RED='\033[0;31m'
export BLUE='\033[0;34m'
export NC='\033[0m' # No Color
# Verbosity
export VERBOSE=false

###### HELPER FUNCTIONS
# TMP_DIR STACK SERVICES
function tmp_dir_stack_files(){
    if [ ! -d "${TMP_DIR}" ]; then
        if [ "${VERBOSE}" = true ]; then
            printf "${TMP_DIR} not found. Creating... \n"
        fi
        mkdir -p ${TMP_DIR}
    fi
}

# TMP_STACK FILES AGE
function tmp_stack_files_age(){
    tmp_dir_stack_files
    for STACK in $(find ${DC_DIR} -name docker-compose.yml -printf '%h \n' | sort -u);
    do
        STACK_NAME=$(basename ${STACK})
        if [ -f ${TMP_DIR}/${STACK_NAME} ]; then
            if [ "${VERBOSE}" = true ]; then
                printf "File exists, checking age \n"
            fi
            if [ "$(find ${TMP_DIR}/${STACK_NAME} -mmin +30)" ]; then
                if [ "${VERBOSE}" = true ]; then
                    printf "File is too old, refreshing \n"
                fi
                cd ${STACK}
                ${DC_COMMAND} ps --services -a > ${TMP_DIR}/${STACK_NAME}
                cd - > /dev/null
            fi
        else
            if [ "${VERBOSE}" = true ]; then
                printf "File does not exist, creating \n"
            fi
            cd ${STACK}
            ${DC_COMMAND} ps --services -a > ${TMP_DIR}/${STACK_NAME}
            cd - > /dev/null
        fi
    done
}

###### MAIN FUNCTIONS
# USAGE
function show_usage (){
    printf "Usage: $0 [command] [stacks] \n"
    printf " \n"
    printf "Commands: \n"
    printf " ${RED}install${NC}              Install dc for the user, needs sudo \n"
    printf " ${RED}up${NC}                   Bring up all stacks, a stack, or stacks \n"
    printf " ${RED}down${NC}                 Bring down all stacks, a stack or stack(s) \n"
    printf " ${RED}restart-stack-hard${NC}   Restarts all stacks, a stack or stack(s) \n"
    printf " ${RED}restart-stack-soft${NC}   Restarts all stacks, a stack or stack(s) \n"
    printf " ${RED}logs-stack${NC}           Shows logs for a stack or stacks \n"
    printf " ${RED}start${NC}                Starts one or more services \n"
    printf " ${RED}stop${NC}                 Stops one or more services \n"
    printf " ${RED}restart${NC}              Restarts one or more services \n"
    printf " ${RED}pull${NC}                 Pulls an image of a service \n"
    printf " ${RED}logs${NC}                 Shows logs for a service or services \n"
    printf " ${RED}network${NC}              Create the MacVLAN network, needs sudo \n"
    printf " ${RED}list${NC}                 List stacks and services in the stacks \n"
    printf " ${RED}help${NC}                 Print help \n"
    printf " ${RED}update${NC}               Updates dc to the latest version \n"
    printf " ${RED}version${NC}              Shows the version and checks the latest version \n"

return 0
}

# INSTALL
function install(){
    ###### PREREQUISITE CHECKS
    # tee
    if ! command -v tee &> /dev/null
    then
        printf "tee could not be found, please install it to use dc \n"
        exit 1
    fi
    # curl
    if ! command -v curl &> /dev/null
    then
        printf "curl could not be found, please install it to use dc \n"
        exit 1
    fi
    # grep
    if ! command -v grep &> /dev/null
    then
        printf "grep could not be found, please install it to use dc \n"
        exit 1
    fi
    # unzip
    if ! command -v unzip &> /dev/null
    then
        printf "unzip could not be found, please install it to use dc \n"
        exit 1
    fi
    # wget
    if ! command -v wget &> /dev/null
    then
        printf "wget could not be found, please install it to use dc \n"
        exit 1
    fi
    # Checking for docker compose or docker-compose
    if docker compose &> /dev/null ; then
        printf "Found ${RED}docker compose${NC} \n"
        export DC_CMD="docker compose"
    elif docker-compose &> /dev/null ; then
        printf "Found ${RED}docker-compose${NC} \n"
        printf "Checking ${RED}docker-compose${NC} version \n"
        DOCKER_COMPOSE_VERSION="$(docker-compose --version | cut -d " " -f 3 | cut -d "," -f 1)"
        MIN_VERSION="1.25.0"
        if [ ! "$(printf '%s\n' "${MIN_VERSION}" "${DOCKER_COMPOSE_VERSION}" | sort -V | head -n1)" = "${MIN_VERSION}" ]; then
            printf "You are running docker-compose version ${DOCKER_COMPOSE_VERSION}. This script requires version ${MIN_VERSION} or higher, due to the use of the --env-file option. \n"
            printf "Please install a newer version of docker-compose. You can find this at https://github.com/docker/compose/releases \n"
            exit 1
        fi
        export DC_CMD="docker-compose"
    else
        printf "Could not find either ${RED}docker compose${NC} or ${RED}docker-compose${NC} on this system. Please install either one (${RED}docker compose${NC} is preferred) to use ${RED}dc${NC} \n"
    fi
    unset DC_DIR
    printf "Home directory is ${HOME} \n"
    printf "Copying dc binary to ${HOME}/bin and making it executable \n"
    if [ ! -d ${HOME}/bin ]; then
        printf "${HOME}/bin does not exist. Creating... \n"
        mkdir -p ${HOME}/bin
    fi
    cp -f dc ${HOME}/bin
    chmod 744 ${HOME}/bin/dc
    # Do stuff here
    printf "Copying dc-completion binary to ${HOME}/.bash_completion.d/ and making it executable \n"
    # Check for root access
    if [ ! -d ${HOME}/.bash_completion.d ]; then
        printf "${HOME}/.bash_completion.d does not exist. Creating... \n"
        mkdir -p ${HOME}/.bash_completion.d
    fi
    if [ ! -f ${HOME}/.bash_completion ]; then
        printf "${HOME}/.bash_completion does not exist. Creating... \n"
        touch ${HOME}/.bash_completion
        printf "Adding bash_completion lines to file \n"
        echo -e "for bcfile in ~/.bash_completion.d/* ; do\n  . \$bcfile\ndone" >> ${HOME}/.bash_completion
        echo "source ${HOME}/.bash_completion" >> ${HOME}/.bashrc
    fi
    cp -f dc-completion ${HOME}/.bash_completion.d
    chmod u+x ${HOME}/.bash_completion.d/dc-completion
    # Add dc to PATH
    if ! grep -q "\$HOME/bin" ${HOME}/.bashrc; then
        printf "Adding dc to PATH \n"
        echo "PATH=\"\$HOME/bin:\$PATH\"" >> ${HOME}/.bashrc
        echo "export PATH" >> ${HOME}/.bashrc
    fi
    # Add DC_DIR to bashrc
    if ! grep -q DC_DIR ${HOME}/.bashrc; then
        printf "Set DC_DIR variable and add to ${HOME}/.bashrc \n"
        read -p "Where are your docker-compose stacks located? " DC_DIR
        echo "export DC_DIR=${DC_DIR}" >> ${HOME}/.bashrc
    fi
    # Add DC_CMD to bashrc
    if ! grep -q DC_CMD ${HOME}/.bashrc; then
        printf "Set DC_CMD command variable and add to ${HOME}/.bashrc \n"
        echo "export DC_CMD='${DC_CMD}'" >> ${HOME}/.bashrc
    else
        printf "Replacing DC_CMD variable \n"
        sed -i '/DC_CMD=/d' ${HOME}/.bashrc
        echo "export DC_CMD='${DC_CMD}'" >> ${HOME}/.bashrc
    fi
}

# UP
function up(){
    if [ -z "$1" ]; then
        printf "No argument provided, please use the name of a stack or all \n"
    elif [ "$1" == "all" ]; then
        printf "Bringing up all stacks \n"
        for STACK in $(find ${DC_DIR} -name docker-compose.yml -printf '%h\n' | sort -u);
        do
            printf "\n${STACK}:\n"
            cd $STACK
            ${DC_COMMAND} up -d
            cd - > /dev/null
        done
    else
        for STACK in $@;
        do
            STACK_DIR="${DC_DIR}/${STACK}"
            if [ -d "${STACK_DIR}" ]; then
                printf "Bringing up stack ${STACK} \n"
                cd ${STACK_DIR}
                ${DC_COMMAND} up -d
                cd - > /dev/null
            else
                printf "Stack ${STACK} does not exist. Did you type the name correctly? \n"
            fi
        done
    fi
    }

# DOWN
function down(){
    if [ -z "$1" ]; then
        printf "No argument provided, please use the name of a stack or all \n"
    elif [ "$1" == "all" ]; then
        printf "Bringing down all stacks \n"
        for STACK in $(find ${DC_DIR} -name docker-compose.yml -printf '%h\n' | sort -ur);
        do
            printf "\n${STACK}:\n"
            cd ${STACK}
            ${DC_COMMAND} down
            cd - > /dev/null
        done
    else
        for STACK in $@;
        do
            STACK_DIR="${DC_DIR}/${STACK}"
            if [ -d "${STACK_DIR}" ]; then
                printf "Bringing down stack ${STACK} \n"
                cd ${STACK_DIR}
                ${DC_COMMAND} down
                cd - > /dev/null
            else
                printf "Stack ${STACK} does not exist. Did you type the name correctly? \n"
            fi
        done
    fi
    }

# RESTART-STACK
## HARD
# RESTART-STACK
function restart-stack-hard(){
    if [ -z "$1" ]; then
        printf "No argument provided, please use the name of a stack or all \n"
    elif [ "$1" == "all" ]; then
        printf "Hard Restarting all stacks \n"
        for STACK in $(find ${DC_DIR} -name docker-compose.yml -printf '%h\n' | sort -u);
        do
            printf "\n${STACK}:\n"
            cd $STACK
            ${DC_COMMAND} down
            ${DC_COMMAND} up -d
            cd - > /dev/null
        done
    else
        for STACK in $@;
        do
            STACK_DIR="${DC_DIR}/${STACK}"
            if [ -d "${STACK_DIR}" ]; then
                printf "Restarting stack ${STACK} \n"
                cd ${STACK_DIR}
                ${DC_COMMAND} down
                ${DC_COMMAND} up -d
                cd - > /dev/null
            else
                printf "Stack ${STACK} does not exist. Did you type the name correctly? \n"
            fi
        done
    fi
    }

## SOFT
function restart-stack-soft(){
    if [ -z "$1" ]; then
        printf "No argument provided, please use the name of a stack or all \n"
    elif [ "$1" == "all" ]; then
        printf "Restarting all stacks \n"
        for STACK in $(find ${DC_DIR} -name docker-compose.yml -printf '%h\n' | sort -u);
        do
            printf "\n${STACK}:\n"
            cd $STACK
            ${DC_COMMAND} restart
            cd - > /dev/null
        done
    else
        for STACK in $@;
        do
            STACK_DIR="${DC_DIR}/${STACK}"
            if [ -d "${STACK_DIR}" ]; then
                printf "Restarting stack ${STACK} \n"
                cd ${STACK_DIR}
                ${DC_COMMAND} restart
                cd - > /dev/null
            else
                printf "Stack ${STACK} does not exist. Did you type the name correctly? \n"
            fi
        done
    fi
    }

# RESTART-STACK
function logs-stack(){
    if [ -z "$1" ]; then
        printf "No argument provided, please provide the name(s) of a stack(s) \n"
    else
        for STACK in $@;
        do
            STACK_DIR="${DC_DIR}/${STACK}"
            if [ -d "${STACK_DIR}" ]; then
                printf "Showing logs for stack ${STACK} \n"
                cd ${STACK_DIR}
                ${DC_COMMAND} logs --tail=100 -f
                cd - > /dev/null
            else
                printf "Stack ${STACK} does not exist. Did you type the name correctly? \n"
            fi
        done
    fi
    }

# # Something to add to start: check if container is exited or not, and then use proper command to start
# To check if a container is exited
# docker-compose ps | grep Exit | cut -d " " -f 1
# START
function start(){
    if [ -z "$1" ]; then
        printf "No argument provided, please provide the name of one or more services \n"
    else
        printf "Starting the following service(s): $@ \n"
        tmp_stack_files_age
        for SERVICE in $@;
        do
            if grep -r -q -x ${SERVICE} ${TMP_DIR}; then
                SERVICE_STACK=$(basename $(grep -r -x ${SERVICE} ${TMP_DIR} | cut -d : -f 1 ))
                if [ "${VERBOSE}" = true ]; then
                    printf "${SERVICE_STACK} \n"
                    printf "Found ${SERVICE} in ${SERVICE_STACK} \n"
                fi
                cd ${DC_DIR}/${SERVICE_STACK}
                ${DC_COMMAND} up -d ${SERVICE}
                cd - > /dev/null
            else
                printf "ERROR: Service ${SERVICE} was not found in any of the stacks. Does it show up when you run ${RED}dc list${NC}? \n"
            fi
        done
    fi
    }

# STOP
# Stop also removes the image
function stop(){
    if [ -z "$1" ]; then
        printf "No argument provided, please provide the name of one or more services \n"
    else
        printf "Stopping the following service(s): $@ \n"
        tmp_stack_files_age
        for SERVICE in $@;
        do
            if grep -r -q -x ${SERVICE} ${TMP_DIR}; then
                SERVICE_STACK=$(basename $(grep -r -x ${SERVICE} ${TMP_DIR} | cut -d : -f 1 ))
                if [ "${VERBOSE}" = true ]; then
                    printf "${SERVICE_STACK} \n"
                    printf "Found ${SERVICE} in ${SERVICE_STACK} \n"
                    printf "${DC_DIR} \n"
                    printf "cd ${DC_DIR}/${SERVICE_STACK} \n"
                fi
                cd ${DC_DIR}/${SERVICE_STACK}
                ${DC_COMMAND} stop ${SERVICE}
                ${DC_COMMAND} rm -f ${SERVICE}
                cd - > /dev/null
            else
                printf "ERROR: Service ${SERVICE} was not found in any of the stacks. Does it show up when you run ${RED}dc list${NC}? \n"
            fi
        done
    fi
    }

# RESTART
# Restart is basically a stop and start in sequence
function restart(){
    if [ -z "$1" ]; then
        printf "No argument provided, please provide the name of one or more services \n"
    else
        printf "Restarting the following service(s): $@ \n"
        stop $@
        start $@
    fi
    }

# PULL
function pull(){
    if [ -z "$1" ]; then
        printf "No argument provided, please provide the name of one or more services \n"
    else
        printf "Pulling images for the following service(s): $@ \n"
        tmp_stack_files_age
        for SERVICE in $@;
        do
            if grep -r -q -x ${SERVICE} ${TMP_DIR}; then
                SERVICE_STACK=$(basename $(grep -r -x ${SERVICE} ${TMP_DIR} | cut -d : -f 1 ))
                if [ "${VERBOSE}" = true ]; then
                    printf "${SERVICE_STACK} \n"
                    printf "Found ${SERVICE} in ${SERVICE_STACK} \n"
                fi
                cd ${DC_DIR}/${SERVICE_STACK}
                printf "Running command: ${DC_COMMAND} pull ${SERVICE} \n"
                ${DC_COMMAND} pull ${SERVICE}
                cd - > /dev/null
            else
                printf "ERROR: Service ${SERVICE} was not found in any of the stacks. Does it show up when you run ${RED}dc list${NC}? \n"
            fi
        done
    fi
    }

function logs(){
    # Need this function to ensure that all child process are killed from the logs command
    if [ -z "$1" ]; then
        printf "No argument provided, please provide the name of one or more services \n"
    else
        trap_kill(){
        for PID in $WAIT_PIDS;
        do
            if [ "${VERBOSE}" = true ]; then
                printf "\$PID is $PID \n"
            fi
            CHILD_PID=`ps --ppid $PID -o pid=`
            if [ "${VERBOSE}" = true ]; then
                printf "CHILD_PID is $CHILD_PID \n"
            fi
            kill $CHILD_PID
        done
        }
        printf "Showing logs for the following service(s): $@ \n"
        tmp_stack_files_age
        for SERVICE in $@;
        do
            if grep -r -q -x ${SERVICE} ${TMP_DIR}; then
                SERVICE_STACK=$(basename $(grep -r -x ${SERVICE} ${TMP_DIR} | cut -d : -f 1 ))
                if [ "${VERBOSE}" = true ]; then
                    printf "${SERVICE_STACK} \n"
                    printf "Found ${SERVICE} in ${SERVICE_STACK} \n"
                fi
                cd ${DC_DIR}/${SERVICE_STACK}
                ${DC_COMMAND} logs --tail=100 -f ${SERVICE} &
                if [ -z "$WAIT_PIDS" ]
                    then
                        export WAIT_PIDS="$!"
                    else
                        export WAIT_PIDS="$WAIT_PIDS $!"
                fi
                printf "PID=$! \n"
                cd - > /dev/null
            else
                printf "ERROR: Service ${SERVICE} was not found in any of the stacks. Does it show up when you run ${RED}dc list${NC}? \n"
            fi
        done
        if [ "${VERBOSE}" = true ]; then
            printf "\$WAIT_PIDS contains $WAIT_PIDS \n"
        fi
        trap 'trap_kill' SIGHUP SIGINT SIGQUIT SIGTERM
        wait $WAIT_PIDS
    fi
    }

# NETWORK
function network(){
    printf "This function does nothing (yet) \n"
    }

# LIST
function list(){
    tmp_dir_stack_files
    printf "Listing Stacks and Services \n"
    for STACK in $(find ${DC_DIR} -name docker-compose.yml -printf '%h\n' | sort -u);
    do
        STACK_NAME=$(basename ${STACK})
        printf "=================================== \n"
        printf "Stack ${RED}${STACK_NAME}${NC} contains services: \n"
        cd ${STACK}
        ${DC_COMMAND} ps --services -a | tee ${TMP_DIR}/${STACK_NAME}
        cd - > /dev/null
    done
    }

###### CASES
# Verbosity, yes, no?
while getopts ":v" opt; do
    case $opt in
        v)
            export VERBOSE=true
            ;;
        \?)
            printf "${opt} \n"
            printf "${OPTARG} \n"
            printf "Invalid option ${RED}-${OPTARG}${NC} provided \n"
            printf "Currently allowed option is: \n"
            printf " ${RED}-v${NC}        Enables verbosity \n"
            exit
            ;;
    esac
done
    shift $(( OPTIND - 1 ))
    case ${1} in
    # ----------- install ------------
        "install")
            install
            ;;

    # ----------- up ------------
        "up")
            up ${@:2}
            ;;

    # ----------- down ------------
        "down")
            down ${@:2}
            ;;

    # ----------- restart-stack-hard ------------
        "restart-stack-hard")
            restart-stack-hard ${@:2}
            ;;

    # ----------- restart-stack-soft ------------
        "restart-stack-soft")
            restart-stack-soft ${@:2}
            ;;

    # ----------- logs-stack ------------
        "logs-stack")
            logs-stack ${@:2}
            ;;

    # ----------- start ------------
        "start")
            start ${@:2}
            ;;

    # ----------- stop ------------
        "stop")
            stop ${@:2}
            ;;

    # ----------- restart ------------
        "restart")
            restart ${@:2}
            ;;

    # ----------- pull ------------
        "pull")
            pull ${@:2}
            ;;

    # ----------- logs ------------
        "logs")
            logs ${@:2}
            ;;

    # ----------- network ------------
        "network")
            network
            ;;

    # ----------- list ------------
        "list")
            list
            ;;
    # ----------- update ------------
        "update")
            export LATEST_VERSION=$(curl --silent https://api.github.com/repos/brhahlen/dc/releases/latest | grep -Po '"tag_name": "\K.*?(?=")')
            export UPDATE_TMP=/tmp/dc_update
            printf "You are on version ${DC_VERSION} of ${RED}dc${NC} \n"
                if [ ! "$(printf '%s\n' "${LATEST_VERSION}" "${DC_VERSION}" | sort -V | head -n1)" = "${LATEST_VERSION}" ]; then
                    printf "Version ${BLUE}${LATEST_VERSION}${NC} of ${RED}dc${NC} is available and will be downloaded and installed \n"
                    if [ ! -d ${UPDATE_TMP} ]; then
                        printf "${UPDATE_TMP} does not exist. Creating... \n"
                        mkdir -p ${UPDATE_TMP}
                    else
                        printf "Cleanup previous update files... \n"
                        rm -rf ${UPDATE_TMP}
                        mkdir ${UPDATE_TMP}
                    fi
                    printf "Downloading... \n"
                    wget -q --show-progress https://github.com/brhahlen/dc/releases/download/${LATEST_VERSION}/dc-release.zip -O ${UPDATE_TMP}/dc-release.zip
                    printf "Extracting... \n"
                    unzip ${UPDATE_TMP}/dc-release.zip -d ${UPDATE_TMP}
                    printf "Updating... \n"
                    cd ${UPDATE_TMP}
                    bash ${UPDATE_TMP}/dc install
                    cd - > /dev/null
                    printf "Done \n"
                else
                    printf "This is the latest version, no update needed \n"
                fi
            ;;
    # ----------- version ------------
        "version")
            export LATEST_VERSION=$(curl --silent https://api.github.com/repos/brhahlen/dc/releases/latest | grep -Po '"tag_name": "\K.*?(?=")')
            if [[ ${DC_VERSION} =~ "dev" ]]; then
                printf "This is version ${RED}${DC_VERSION}${NC} of ${RED}dc${NC} \n"
                printf "This is a development version \n"
                printf "The latest release version is ${BLUE}${LATEST_VERSION}${NC} \n"
            else
                printf "This is version ${DC_VERSION} of ${RED}dc${NC} \n"
                printf "Release notes can be found at https://github.com/brhahlen/dc/releases/tag/${DC_VERSION} \n"
                if [ ! "$(printf '%s\n' "${LATEST_VERSION}" "${DC_VERSION}" | sort -V | head -n1)" = "${LATEST_VERSION}" ]; then
                    printf "#################################### \n"
                    printf "A newer version of ${RED}dc${NC} is avaiable \n"
                    printf "The latest release version is ${BLUE}${LATEST_VERSION}${NC} \n"
                    printf "This can be found at https://github.com/brhahlen/dc/releases/tag/${LATEST_VERSION} \n"
                fi
            fi
            ;;
    # ----------- All others ------------
        "help")
            show_usage
            ;;
        "")
            printf "Missing command, showing help \n"
            show_usage
            ;;
        *)
            printf "Invalid command ${RED}${1}${NC}, showing help \n"
            show_usage
            ;;
    esac
#done
