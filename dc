#!/bin/bash
##################################
# Copyright (C) 2022 Ben HÃ¤hlen
##################################
# VERSION
export DC_VERSION=v2.0.0-dev

###### VARIABLES
if [[ -z "${DC_DIR}" ]]; then
    export DC_DIR="${HOME}/docker"
else
    export DC_DIR="${DC_DIR}"
fi
export ENV="${DC_DIR}/.env"

#######################################
export DC_CMD="docker compose"
export DC_COMMAND="${DC_CMD} --env-file ${ENV}"
export TMP_DIR="/tmp/dc_stack_services"
# COLORS
export RED='\033[0;31m'
export BLUE='\033[0;34m'
export NC='\033[0m' # No Color
# Verbosity
export VERBOSE=false

##################################################
# HELPER FUNCTIONS                               #
##################################################
# TMP_DIR STACK SERVICES
function tmp_dir_stack_files(){
    if [ ! -d "${TMP_DIR}" ]; then
        if [ "${VERBOSE}" = true ]; then
            printf "%s not found. Creating... \n" "${TMP_DIR}"
        fi
        mkdir -p ${TMP_DIR}
    fi
}

# TMP_STACK FILES AGE
function tmp_stack_files_age(){
    tmp_dir_stack_files
    for STACK in $(find "${DC_DIR}" -name docker-compose.yml -printf '%h \n' | sort -u);
    do
        STACK_NAME=$(basename "${STACK}")
        if [ -f "${TMP_DIR}"/"${STACK_NAME}" ]; then
            if [ "${VERBOSE}" = true ]; then
                printf "File %s/%s exists, checking age \n" "${TMP_DIR}" "${STACK_NAME}"
            fi
            if [ "$(find ${TMP_DIR}/"${STACK_NAME}" -mmin +30)" ]; then
                if [ "${VERBOSE}" = true ]; then
                    printf "File is too old, refreshing \n"
                fi
                cd "${STACK}" || { echo "cd failed"; exit 1; }
                ${DC_COMMAND} config --services > "${TMP_DIR}"/"${STACK_NAME}"
                cd - > /dev/null || { echo "cd failed"; exit 1; }
            fi
        else
            if [ "${VERBOSE}" = true ]; then
                printf "File does not exist, creating \n"
            fi
            cd "${STACK}" || { echo "cd failed"; exit 1; }
           " ${DC_COMMAND}" config --services > "${TMP_DIR}"/"${STACK_NAME}"
            cd - > /dev/null || { echo "cd failed"; exit 1; }
        fi
    done
}

##################################################
# USAGE AND LIST                                 #
##################################################
# USAGE
function show_usage (){
    printf "Usage: %s [command] [stacks] \n" "$0"
    printf " \n"
    printf "Commands: \n"
    printf "============================= Stack Commands ============================="
    printf " %bup%b                   Bring up all stacks, a stack, or stacks \n" "${RED}" "${NC}"
    printf " %bdown%b                 Bring down all stacks, a stack or stack(s) \n" "${RED}" "${NC}"
    printf " %brestart-stack-hard%b   Restarts all stacks, a stack or stack(s) \n" "${RED}" "${NC}"
    printf " %brestart-stack-soft%b   Restarts all stacks, a stack or stack(s) \n" "${RED}" "${NC}"
    printf " %blogs-stack%b           Shows logs for a stack or stacks \n" "${RED}" "${NC}"
    printf "=========================== Container Commands ==========================="
    printf " %bstart%b                Starts one or more services \n" "${RED}" "${NC}"
    printf " %bstop%b                 Stops one or more services \n" "${RED}" "${NC}"
    printf " %brestart%b              Restarts one or more services \n" "${RED}" "${NC}"
    printf " %bpull%b                 Pulls an image of a service \n" "${RED}" "${NC}"
    printf " %blogs%b                 Shows logs for a service or services \n" "${RED}" "${NC}"
    printf "============================= System Commands ============================="
    printf " %bnetwork%b              Create the MacVLAN network, needs sudo \n" "${RED}" "${NC}"
    printf " %bprune%b                Prunes images and containers (basic) or the system \n" "${RED}" "${NC}"
    printf "======================= Install, Update and Version ======================="
    printf " %binstall%b              Install dc for the user, needs sudo \n" "${RED}" "${NC}"
    printf " %bupdate%b               Updates dc to the latest version \n" "${RED}" "${NC}"
    printf " %bversion%b              Shows the version and checks the latest version \n" "${RED}" "${NC}"
    printf "============================== Usage Commands =============================="
    printf " %blist%b                 List stacks and services in the stacks \n" "${RED}" "${NC}"
    printf " %bhelp%b                 Print help \n" "${RED}" "${NC}"

return 0
}

# LIST
function list(){
    tmp_dir_stack_files
    printf "Listing Stacks and Services \n"
    for STACK in $(find "${DC_DIR}" -name docker-compose.yml -printf '%h\n' | sort -u);
    do
        STACK_NAME=$(basename "${STACK}")
        printf "=================================== \n"
        printf "Stack %b%s%b contains services: \n" "${RED}" "${STACK_NAME}" "${NC}"
        cd "${STACK}" || { echo "cd failed"; exit 1; }
        ${DC_COMMAND} config --services | tee ${TMP_DIR}/"${STACK_NAME}"
        cd - > /dev/null || { echo "cd failed"; exit 1; }
    done
    }

##################################################
# INSTALLATION/UPDATE/VERSION CHECKING STUFF     #
##################################################
# INSTALL
function install(){
    ###### PREREQUISITE CHECKS
    # tee
    if ! command -v tee &> /dev/null ; then
        printf "tee could not be found, please install it to use dc \n"
        exit 1
    fi
    # curl
    if ! command -v curl &> /dev/null ; then
        printf "curl could not be found, please install it to use dc \n"
        exit 1
    fi
    # grep
    if ! command -v grep &> /dev/null ; then
        printf "grep could not be found, please install it to use dc \n"
        exit 1
    fi
    # unzip
    if ! command -v unzip &> /dev/null ; then
        printf "unzip could not be found, please install it to use dc \n"
        exit 1
    fi
    # wget
    if ! command -v wget &> /dev/null ; then
        printf "wget could not be found, please install it to use dc \n"
        exit 1
    fi
    # Checking for docker compose or docker-compose
    if docker compose &> /dev/null ; then
        printf "Found %bdocker compose%b \n" "${RED}" "${NC}"
        export DC_CMD="docker compose"
    else
        printf "Could not find either %bdocker compose%b. Please install %bdocker compose%b to use %bdc%b \n" "${RED}" "${NC}" "${RED}" "${NC}" "${RED}" "${NC}"
    fi
    unset DC_DIR
    printf "Home directory is %s \n" "${HOME}"
    printf "Copying dc binary to%s/bin and making it executable \n" "${HOME}"
    if [ ! -d "${HOME}"/bin  ]; then
        printf "%s/bin does not exist. Creating... \n" "${HOME}"
        mkdir -p "${HOME}"/bin
    fi
    cp -f dc "${HOME}"/bin
    chmod 744 "${HOME}"/bin/dc
    # Do stuff here
    printf "Copying dc-completion binary to %s/.bash_completion.d/ and making it executable \n" "${HOME}"
    # Check for root access
    if [ ! -d "${HOME}"/.bash_completion.d ] ; then
        printf "%s/.bash_completion.d does not exist. Creating... \n" "${HOME}"
        mkdir -p "${HOME}"/.bash_completion.d
    fi
    if [ ! -f "${HOME}"/.bash_completion ] ; then
        printf "%s/.bash_completion does not exist. Creating... \n" "${HOME}"
        touch "${HOME}"/.bash_completion
        printf "Adding bash_completion lines to file \n"
        echo -e "for bcfile in ~/.bash_completion.d/* ; do\n  . \$bcfile\ndone" >> "${HOME}"/.bash_completion
        echo "source ${HOME}/.bash_completion" >> "${HOME}"/.bashrc
    fi
    cp -f dc-completion "${HOME}"/.bash_completion.d
    chmod u+x "${HOME}"/.bash_completion.d/dc-completion
    # Add dc to PATH
    if ! grep -q "\$HOME/bin" "${HOME}"/.bashrc ; then
        printf "Adding dc to PATH \n"
        echo "PATH=\"\$HOME/bin:\$PATH\"" >> "${HOME}"/.bashrc
        echo "export PATH" >> "${HOME}"/.bashrc
    fi
    # Add DC_DIR to bashrc
    if ! grep -q DC_DIR "${HOME}"/.bashrc ; then
        printf "Set DC_DIR variable and add to %s/.bashrc \n" "${HOME}"
        read -r -p "Where are your docker-compose stacks located? " DC_DIR
        echo "export DC_DIR=${DC_DIR}" >> "${HOME}"/.bashrc
    fi
    # Remove DC_CMD to bashrc
    if grep -q DC_CMD "${HOME}"/.bashrc ; then
        printf "Removing DC_CMD variable \n"
        sed -i '/DC_CMD=/d' "${HOME}"/.bashrc
    fi
}

# VERSION
function show_version(){
    LATEST_VERSION=$(curl --silent https://api.github.com/repos/brhahlen/dc/releases/latest | grep -Po '"tag_name": "\K.*?(?=")')
    export LATEST_VERSION
    if [[ ${DC_VERSION} =~ "dev" ]]; then
        printf "This is version %b%s%b of %bdc%b \n" "${RED}" "${DC_VERSION}" "${NC}" "${RED}" "${NC}"
        printf "This is a development version \n"
        printf "The latest release version is %b%s%b \n" "${BLUE}" "${LATEST_VERSION}" "${NC}"
    else
        printf "This is version %b%s%b of %bdc%b \n" "${RED}" "${DC_VERSION}" "${NC}" "${RED}" "${NC}"
        printf "Release notes can be found at https://github.com/brhahlen/dc/releases/tag/%s \n" "${DC_VERSION}"
        if [ ! "$(printf '%s\n' "${LATEST_VERSION}" "${DC_VERSION}" | sort -V | head -n1)" = "${LATEST_VERSION}" ]; then
            printf "#################################### \n"
            printf "A newer version of %bdc%b is avaiable \n" "${RED}" "${NC}"
            printf "The latest release version is %b%s%b \n" "${BLUE}" "${LATEST_VERSION}" "${NC}"
            printf "This can be found at https://github.com/brhahlen/dc/releases/tag/%s \n" "${LATEST_VERSION}"
        fi
    fi
}

function update(){
    LATEST_VERSION=$(curl --silent https://api.github.com/repos/brhahlen/dc/releases/latest | grep -Po '"tag_name": "\K.*?(?=")')
    export LATEST_VERSION
    export UPDATE_TMP=/tmp/dc_update
    printf "You are on version %s of %bdc%b \n" "${DC_VERSION}" "${RED}" "${NC}"
        if [ ! "$(printf '%s\n' "${LATEST_VERSION}" "${DC_VERSION}" | sort -V | head -n1)" = "${LATEST_VERSION}" ]; then
            printf "Version %b%s%b of %bdc%b is available and will be downloaded and installed \n" "${BLUE}" "${LATEST_VERSION}" "${NC}" "${RED}" "${NC}"
            if [ ! -d ${UPDATE_TMP} ]; then
                printf "%s does not exist. Creating... \n" "${UPDATE_TMP}"
                mkdir -p "${UPDATE_TMP}"
            else
                printf "Cleanup previous update files... \n"
                rm -rf "${UPDATE_TMP}"
                mkdir "${UPDATE_TMP}"
            fi
            printf "Downloading... \n"
            wget -q --show-progress https://github.com/brhahlen/dc/releases/download/"${LATEST_VERSION}"/dc-release.zip -O "${UPDATE_TMP}"/dc-release.zip
            printf "Extracting... \n"
            unzip -q "${UPDATE_TMP}"/dc-release.zip -d "${UPDATE_TMP}"
            printf "Updating... \n"
            cd "${UPDATE_TMP}" || { echo "cd failed"; exit 1; }
            bash "${UPDATE_TMP}"/dc install
            cd - > /dev/null || { echo "cd failed"; exit 1; }
            printf "Done \n"
        else
            printf "This is the latest version, no update needed \n"
        fi
}

##################################################
# STACK COMMANDS                                 #
##################################################
# UP
function up(){
    if [ -z "$1" ]; then
        printf "No argument provided, please use the name of a stack or all \n"
    elif [ "$1" == "all" ]; then
        printf "Bringing up all stacks \n"
        for STACK in $(find "${DC_DIR}" -name docker-compose.yml -printf '%h\n' | sort -u);
        do
            printf "\n%s:\n" "${STACK}"
            cd "${STACK}" || { echo "cd failed"; exit 1; }
            ${DC_COMMAND} up -d
            cd - > /dev/null || { echo "cd failed"; exit 1; }
        done
    else
        for STACK in "$@";
        do
            STACK_DIR="${DC_DIR}/${STACK}"
            if [ -d "${STACK_DIR}" ]; then
                printf "Bringing up stack %s \n" "${STACK}"
                cd "${STACK_DIR}" || { echo "cd failed"; exit 1; }
                ${DC_COMMAND} up -d
                cd - > /dev/null || { echo "cd failed"; exit 1; }
            else
                printf "Stack %s does not exist. Did you type the name correctly? \n" "${STACK}"
            fi
        done
    fi
    }

# DOWN
function down(){
    if [ -z "$1" ]; then
        printf "No argument provided, please use the name of a stack or all \n"
    elif [ "$1" == "all" ]; then
        printf "Bringing down all stacks \n"
        for STACK in $(find "${DC_DIR}" -name docker-compose.yml -printf '%h\n' | sort -ur);
        do
            printf "\n%s:\n" "${STACK}"
            cd "${STACK}" || { echo "cd failed"; exit 1; }
            ${DC_COMMAND} down
            cd - > /dev/null || { echo "cd failed"; exit 1; }
        done
    else
        for STACK in "$@";
        do
            STACK_DIR="${DC_DIR}/${STACK}"
            if [ -d "${STACK_DIR}" ]; then
                printf "Bringing down stack %s \n" "${STACK}"
                cd "${STACK_DIR}" || { echo "cd failed"; exit 1; }
                ${DC_COMMAND} down
                cd - > /dev/null || { echo "cd failed"; exit 1; }
            else
                printf "Stack %s does not exist. Did you type the name correctly? \n" "${STACK}"
            fi
        done
    fi
    }

# RESTART-STACK
## HARD
# RESTART-STACK
function restart-stack-hard(){
    if [ -z "$1" ]; then
        printf "No argument provided, please use the name of a stack or all \n"
    elif [ "$1" == "all" ]; then
        printf "Hard Restarting all stacks \n"
        for STACK in $(find "${DC_DIR}" -name docker-compose.yml -printf '%h\n' | sort -u);
        do
            printf "\n%s:\n" "${STACK}"
            cd "${STACK}" || { echo "cd failed"; exit 1; }
            ${DC_COMMAND} down
            ${DC_COMMAND} up -d
            cd - > /dev/null || { echo "cd failed"; exit 1; }
        done
    else
        for STACK in "$@";
        do
            STACK_DIR="${DC_DIR}/${STACK}"
            if [ -d "${STACK_DIR}" ]; then
                printf "Restarting stack %s \n" "${STACK}"
                cd "${STACK_DIR}" || { echo "cd failed"; exit 1; }
                ${DC_COMMAND} down
                ${DC_COMMAND} up -d
                cd - > /dev/null || { echo "cd failed"; exit 1; }
            else
                printf "Stack %s does not exist. Did you type the name correctly? \n" "${STACK}"
            fi
        done
    fi
    }

## SOFT
function restart-stack-soft(){
    if [ -z "$1" ]; then
        printf "No argument provided, please use the name of a stack or all \n"
    elif [ "$1" == "all" ]; then
        printf "Restarting all stacks \n"
        for STACK in $(find "${DC_DIR}" -name docker-compose.yml -printf '%h\n' | sort -u);
        do
            printf "\n%s:\n" "${STACK}"
            cd "${STACK}" || { echo "cd failed"; exit 1; }
            ${DC_COMMAND} restart
            cd - > /dev/null || { echo "cd failed"; exit 1; }
        done
    else
        for STACK in "$@";
        do
            STACK_DIR="${DC_DIR}/${STACK}"
            if [ -d "${STACK_DIR}" ]; then
                printf "Restarting stack %s \n" "${STACK}"
                cd "${STACK_DIR}" || { echo "cd failed"; exit 1; }
                ${DC_COMMAND} restart
                cd - > /dev/null || { echo "cd failed"; exit 1; }
            else
                printf "Stack %s does not exist. Did you type the name correctly? \n" "${STACK}"
            fi
        done
    fi
    }

# LOGS-STACK
function logs-stack(){
    if [ -z "$1" ]; then
        printf "No argument provided, please provide the name(s) of a stack(s) \n"
    else
        for STACK in "$@";
        do
            STACK_DIR="${DC_DIR}/${STACK}"
            if [ -d "${STACK_DIR}" ]; then
                printf "Showing logs for stack %s \n" "${STACK}"
                cd "${STACK_DIR}" || { echo "cd failed"; exit 1; }
                ${DC_COMMAND} logs --tail=100 -f
                cd - > /dev/null || { echo "cd failed"; exit 1; }
            else
                printf "Stack %s does not exist. Did you type the name correctly? \n" "${STACK}"
            fi
        done
    fi
    }

##################################################
# CONTAINER COMMANDS                             #
##################################################
# # Something to add to start: check if container is exited or not, and then use proper command to start
# To check if a container is exited
# docker-compose ps | grep Exit | cut -d " " -f 1
# START
function start(){
    if [ -z "$1" ]; then
        printf "No argument provided, please provide the name of one or more services \n"
    else
        printf "Starting the following service(s): %s \n" "$@"
        tmp_stack_files_age
        for SERVICE in "$@";
        do
            if grep -r -q -x "${SERVICE}" "${TMP_DIR}"; then
                SERVICE_STACK=$(basename "$(grep -r -x "${SERVICE}" "${TMP_DIR}" | cut -d : -f 1 )")
                if [ "${VERBOSE}" = true ]; then
                    printf "%s \n" "${SERVICE_STACK}"
                    printf "Found %s in %s \n" "${SERVICE}" "${SERVICE_STACK}"
                fi
                cd "${DC_DIR}"/"${SERVICE_STACK}" || { echo "cd failed"; exit 1; }
                ${DC_COMMAND} up -d "${SERVICE}"
                cd - > /dev/null || { echo "cd failed"; exit 1; }
            else
                printf "ERROR: Service %s was not found in any of the stacks. Does it show up when you run %bdc list%b? \n" "${SERVICE}" "${RED}" "${NC}"
            fi
        done
    fi
    }

# STOP
# Stop also removes the image
function stop(){
    if [ -z "$1" ]; then
        printf "No argument provided, please provide the name of one or more services \n"
    else
        printf "Stopping the following service(s): %s \n" "$@"
        tmp_stack_files_age
        for SERVICE in "$@";
        do
            if grep -r -q -x "${SERVICE}" ${TMP_DIR}; then
                SERVICE_STACK=$(basename "$(grep -r -x "${SERVICE}" ${TMP_DIR} | cut -d : -f 1 )")
                if [ "${VERBOSE}" = true ]; then
                    printf "%s \n" "${SERVICE_STACK}"
                    printf "Found %s in %s \n" "${SERVICE}" "${SERVICE_STACK}"
                    printf "%s \n" "${DC_DIR}"
                    printf "cd %s/%s \n" "${DC_DIR}" "${SERVICE_STACK}"
                fi
                cd "${DC_DIR}"/"${SERVICE_STACK}" || { echo "cd failed"; exit 1; }
                ${DC_COMMAND} stop "${SERVICE}"
                ${DC_COMMAND} rm -f "${SERVICE}"
                cd - > /dev/null || { echo "cd failed"; exit 1; }
            else
                printf "ERROR: Service %s was not found in any of the stacks. Does it show up when you run %bdc list%b? \n" "${SERVICE}" "${RED}" "${NC}"
            fi
        done
    fi
    }

# RESTART
# Restart is basically a stop and start in sequence
function restart(){
    if [ -z "$1" ]; then
        printf "No argument provided, please provide the name of one or more services \n"
    else
        printf "Restarting the following service(s): %s \n" "$@"
        stop "$@"
        start "$@"
    fi
    }

# PULL
function pull(){
    if [ -z "$1" ]; then
        printf "No argument provided, please provide the name of one or more services \n"
    else
        printf "Pulling images for the following service(s): %s \n" "$@"
        tmp_stack_files_age
        for SERVICE in "$@";
        do
            if grep -r -q -x "${SERVICE}" "${TMP_DIR}"; then
                SERVICE_STACK=$(basename "$(grep -r -x "${SERVICE}" ${TMP_DIR} | cut -d : -f 1 )")
                if [ "${VERBOSE}" = true ]; then
                    printf "%s \n" "${SERVICE_STACK}"
                    printf "Found %s in %s \n" "${SERVICE}" "${SERVICE_STACK}"
                fi
                cd "${DC_DIR}"/"${SERVICE_STACK}" || { echo "cd failed"; exit 1; }
                printf "Running command: %s pull %s \n" "${DC_COMMAND}" "${SERVICE}"
                ${DC_COMMAND} pull "${SERVICE}"
                cd - > /dev/null || { echo "cd failed"; exit 1; }
            else
                printf "ERROR: Service %s was not found in any of the stacks. Does it show up when you run %bdc list%b? \n" "${SERVICE}" "${RED}" "${NC}"
            fi
        done
    fi
    }

function logs(){
    # Need this function to ensure that all child process are killed from the logs command
    if [ -z "$1" ]; then
        printf "No argument provided, please provide the name of one or more services \n"
    else
        trap_kill(){
        for PID in $WAIT_PIDS;
        do
            if [ "${VERBOSE}" = true ]; then
                printf "\$PID is %s \n" "${PID}"
            fi
            CHILD_PID=$(ps --ppid "${PID}" -o pid=)
            if [ "${VERBOSE}" = true ]; then
                printf "CHILD_PID is %s \n" "${CHILD_PID}"
            fi
            kill "${CHILD_PID}"
        done
        }
        printf "Showing logs for the following service(s): %s \n" "$@"
        tmp_stack_files_age
        for SERVICE in "$@";
        do
            if grep -r -q -x "${SERVICE}" "${TMP_DIR}"; then
                SERVICE_STACK=$(basename "$(grep -r -x "${SERVICE}" ${TMP_DIR} | cut -d : -f 1 )")
                if [ "${VERBOSE}" = true ]; then
                    printf "%s \n" "${SERVICE_STACK}"
                    printf "Found %s in %s \n" "${SERVICE}" "${SERVICE_STACK}"
                fi
                cd "${DC_DIR}"/"${SERVICE_STACK}" || { echo "cd failed"; exit 1; }
                ${DC_COMMAND} logs --tail=100 -f "${SERVICE}" &
                if [ -z "$WAIT_PIDS" ]
                    then
                        export WAIT_PIDS="$!"
                    else
                        export WAIT_PIDS="$WAIT_PIDS $!"
                fi
                printf "PID=%s \n" "$!"
                cd - > /dev/null || { echo "cd failed"; exit 1; }
            else
                printf "ERROR: Service %s was not found in any of the stacks. Does it show up when you run %bdc list%b? \n" "${SERVICE}" "${RED}" "${NC}"
            fi
        done
        if [ "${VERBOSE}" = true ]; then
            printf "\$WAIT_PIDS contains %s \n" "${WAIT_PIDS}"
        fi
        trap 'trap_kill' SIGHUP SIGINT SIGQUIT SIGTERM
        wait "${WAIT_PIDS}"
    fi
    }

##################################################
# SYSTEM COMMANDS                                #
##################################################
# NETWORK
function network(){
    printf "This function does nothing (yet) \n"
    }

function prune() {
    true
    }

###### CASES
# Verbosity, yes, no?
while getopts ":v" opt; do
    case $opt in
        v)
            export VERBOSE=true
            ;;
        \?)
            printf "%s \n" "${opt}"
            printf "%s \n" "${OPTARG}"
            printf "Invalid option %b-%s%b provided \n" "${RED}" "${OPTARG}" "${NC}"
            printf "Currently allowed option is: \n"
            printf " %b-v%b        Enables verbosity \n" "${RED}" "${NC}"
            exit
            ;;
    esac
done
shift $(( OPTIND - 1 ))
case ${1} in
# ----------- up ------------
    "up")
        up "${@:2}"
        ;;
# ----------- down ------------
    "down")
        down "${@:2}"
        ;;
# ----------- restart-stack-hard ------------
    "restart-stack-hard")
        restart-stack-hard "${@:2}"
        ;;
# ----------- restart-stack-soft ------------
    "restart-stack-soft")
        restart-stack-soft "${@:2}"
        ;;
# ----------- logs-stack ------------
    "logs-stack")
        logs-stack "${@:2}"
        ;;
# ----------- start ------------
    "start")
        start "${@:2}"
        ;;
# ----------- stop ------------
    "stop")
        stop "${@:2}"
        ;;
# ----------- restart ------------
    "restart")
        restart "${@:2}"
        ;;
# ----------- pull ------------
    "pull")
        pull "${@:2}"
        ;;
# ----------- logs ------------
    "logs")
        logs "${@:2}"
        ;;
# ----------- network ------------
    "network")
        network
        ;;
# ----------- install ------------
    "install")
        install
        ;;
# ----------- update ------------
    "update")
        update
        ;;
# ----------- version ------------
    "version")
        show_version
        ;;
# ----------- list ------------
    "list")
        list
        ;;
# ----------- All others ------------
    "help")
        show_usage
        ;;
    "")
        printf "Missing command, showing help \n"
        show_usage
        ;;
    *)
        printf "Invalid command %b%s%b, showing help \n" "${RED}" "${1}" "${NC}"
        show_usage
        ;;
esac
